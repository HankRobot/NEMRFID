"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST API Reference
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.7.15
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
__export(require("./accountDTO"));
__export(require("./accountIds"));
__export(require("./accountInfoDTO"));
__export(require("./accountMetaDTO"));
__export(require("./accountNamesDTO"));
__export(require("./accountRestrictionDTO"));
__export(require("./accountRestrictionTypeEnum"));
__export(require("./accountRestrictionsDTO"));
__export(require("./accountRestrictionsInfoDTO"));
__export(require("./aliasDTO"));
__export(require("./aliasTypeEnum"));
__export(require("./announceTransactionInfoDTO"));
__export(require("./blockDTO"));
__export(require("./blockInfoDTO"));
__export(require("./blockMetaDTO"));
__export(require("./blockchainScoreDTO"));
__export(require("./communicationTimestamps"));
__export(require("./cosignature"));
__export(require("./heightInfoDTO"));
__export(require("./merklePathItem"));
__export(require("./merkleProofInfo"));
__export(require("./merkleProofInfoDTO"));
__export(require("./mosaicDTO"));
__export(require("./mosaicDefinitionDTO"));
__export(require("./mosaicIds"));
__export(require("./mosaicInfoDTO"));
__export(require("./mosaicMetaDTO"));
__export(require("./mosaicNamesDTO"));
__export(require("./mosaicPropertyDTO"));
__export(require("./mosaicPropertyIdEnum"));
__export(require("./multisigAccountGraphInfoDTO"));
__export(require("./multisigAccountInfoDTO"));
__export(require("./multisigDTO"));
__export(require("./multisigModificationTypeEnum"));
__export(require("./namespaceDTO"));
__export(require("./namespaceIds"));
__export(require("./namespaceInfoDTO"));
__export(require("./namespaceMetaDTO"));
__export(require("./namespaceNameDTO"));
__export(require("./namespaceTypeEnum"));
__export(require("./networkTypeDTO"));
__export(require("./nodeInfoDTO"));
__export(require("./nodeTimeDTO"));
__export(require("./receiptTypeEnum"));
__export(require("./resolutionEntryDTO"));
__export(require("./resolutionStatementDTO"));
__export(require("./rolesTypeEnum"));
__export(require("./serverDTO"));
__export(require("./serverInfoDTO"));
__export(require("./sourceDTO"));
__export(require("./statementsDTO"));
__export(require("./storageInfoDTO"));
__export(require("./transactionHashes"));
__export(require("./transactionIds"));
__export(require("./transactionInfoDTO"));
__export(require("./transactionMetaDTO"));
__export(require("./transactionPayload"));
__export(require("./transactionStatementDTO"));
__export(require("./transactionStatusDTO"));
const accountDTO_1 = require("./accountDTO");
const accountIds_1 = require("./accountIds");
const accountInfoDTO_1 = require("./accountInfoDTO");
const accountMetaDTO_1 = require("./accountMetaDTO");
const accountNamesDTO_1 = require("./accountNamesDTO");
const accountRestrictionDTO_1 = require("./accountRestrictionDTO");
const accountRestrictionTypeEnum_1 = require("./accountRestrictionTypeEnum");
const accountRestrictionsDTO_1 = require("./accountRestrictionsDTO");
const accountRestrictionsInfoDTO_1 = require("./accountRestrictionsInfoDTO");
const aliasDTO_1 = require("./aliasDTO");
const aliasTypeEnum_1 = require("./aliasTypeEnum");
const announceTransactionInfoDTO_1 = require("./announceTransactionInfoDTO");
const blockDTO_1 = require("./blockDTO");
const blockInfoDTO_1 = require("./blockInfoDTO");
const blockMetaDTO_1 = require("./blockMetaDTO");
const blockchainScoreDTO_1 = require("./blockchainScoreDTO");
const communicationTimestamps_1 = require("./communicationTimestamps");
const cosignature_1 = require("./cosignature");
const heightInfoDTO_1 = require("./heightInfoDTO");
const merklePathItem_1 = require("./merklePathItem");
const merkleProofInfo_1 = require("./merkleProofInfo");
const merkleProofInfoDTO_1 = require("./merkleProofInfoDTO");
const mosaicDTO_1 = require("./mosaicDTO");
const mosaicDefinitionDTO_1 = require("./mosaicDefinitionDTO");
const mosaicIds_1 = require("./mosaicIds");
const mosaicInfoDTO_1 = require("./mosaicInfoDTO");
const mosaicMetaDTO_1 = require("./mosaicMetaDTO");
const mosaicNamesDTO_1 = require("./mosaicNamesDTO");
const mosaicPropertyDTO_1 = require("./mosaicPropertyDTO");
const mosaicPropertyIdEnum_1 = require("./mosaicPropertyIdEnum");
const multisigAccountGraphInfoDTO_1 = require("./multisigAccountGraphInfoDTO");
const multisigAccountInfoDTO_1 = require("./multisigAccountInfoDTO");
const multisigDTO_1 = require("./multisigDTO");
const multisigModificationTypeEnum_1 = require("./multisigModificationTypeEnum");
const namespaceDTO_1 = require("./namespaceDTO");
const namespaceIds_1 = require("./namespaceIds");
const namespaceInfoDTO_1 = require("./namespaceInfoDTO");
const namespaceMetaDTO_1 = require("./namespaceMetaDTO");
const namespaceNameDTO_1 = require("./namespaceNameDTO");
const namespaceTypeEnum_1 = require("./namespaceTypeEnum");
const networkTypeDTO_1 = require("./networkTypeDTO");
const nodeInfoDTO_1 = require("./nodeInfoDTO");
const nodeTimeDTO_1 = require("./nodeTimeDTO");
const receiptTypeEnum_1 = require("./receiptTypeEnum");
const resolutionEntryDTO_1 = require("./resolutionEntryDTO");
const resolutionStatementDTO_1 = require("./resolutionStatementDTO");
const rolesTypeEnum_1 = require("./rolesTypeEnum");
const serverDTO_1 = require("./serverDTO");
const serverInfoDTO_1 = require("./serverInfoDTO");
const sourceDTO_1 = require("./sourceDTO");
const statementsDTO_1 = require("./statementsDTO");
const storageInfoDTO_1 = require("./storageInfoDTO");
const transactionHashes_1 = require("./transactionHashes");
const transactionIds_1 = require("./transactionIds");
const transactionInfoDTO_1 = require("./transactionInfoDTO");
const transactionMetaDTO_1 = require("./transactionMetaDTO");
const transactionPayload_1 = require("./transactionPayload");
const transactionStatementDTO_1 = require("./transactionStatementDTO");
const transactionStatusDTO_1 = require("./transactionStatusDTO");
/* tslint:disable:no-unused-variable */
let primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
    "any"
];
let enumsMap = {
    "AliasTypeEnum": aliasTypeEnum_1.AliasTypeEnum,
    "MosaicPropertyIdEnum": mosaicPropertyIdEnum_1.MosaicPropertyIdEnum,
    "MultisigModificationTypeEnum": multisigModificationTypeEnum_1.MultisigModificationTypeEnum,
    "NamespaceTypeEnum": namespaceTypeEnum_1.NamespaceTypeEnum,
    "ReceiptTypeEnum": receiptTypeEnum_1.ReceiptTypeEnum,
    "RolesTypeEnum": rolesTypeEnum_1.RolesTypeEnum,
};
let typeMap = {
    "AccountDTO": accountDTO_1.AccountDTO,
    "AccountIds": accountIds_1.AccountIds,
    "AccountInfoDTO": accountInfoDTO_1.AccountInfoDTO,
    "AccountMetaDTO": accountMetaDTO_1.AccountMetaDTO,
    "AccountNamesDTO": accountNamesDTO_1.AccountNamesDTO,
    "AccountRestrictionDTO": accountRestrictionDTO_1.AccountRestrictionDTO,
    "AccountRestrictionTypeEnum": accountRestrictionTypeEnum_1.AccountRestrictionTypeEnum,
    "AccountRestrictionsDTO": accountRestrictionsDTO_1.AccountRestrictionsDTO,
    "AccountRestrictionsInfoDTO": accountRestrictionsInfoDTO_1.AccountRestrictionsInfoDTO,
    "AliasDTO": aliasDTO_1.AliasDTO,
    "AnnounceTransactionInfoDTO": announceTransactionInfoDTO_1.AnnounceTransactionInfoDTO,
    "BlockDTO": blockDTO_1.BlockDTO,
    "BlockInfoDTO": blockInfoDTO_1.BlockInfoDTO,
    "BlockMetaDTO": blockMetaDTO_1.BlockMetaDTO,
    "BlockchainScoreDTO": blockchainScoreDTO_1.BlockchainScoreDTO,
    "CommunicationTimestamps": communicationTimestamps_1.CommunicationTimestamps,
    "Cosignature": cosignature_1.Cosignature,
    "HeightInfoDTO": heightInfoDTO_1.HeightInfoDTO,
    "MerklePathItem": merklePathItem_1.MerklePathItem,
    "MerkleProofInfo": merkleProofInfo_1.MerkleProofInfo,
    "MerkleProofInfoDTO": merkleProofInfoDTO_1.MerkleProofInfoDTO,
    "MosaicDTO": mosaicDTO_1.MosaicDTO,
    "MosaicDefinitionDTO": mosaicDefinitionDTO_1.MosaicDefinitionDTO,
    "MosaicIds": mosaicIds_1.MosaicIds,
    "MosaicInfoDTO": mosaicInfoDTO_1.MosaicInfoDTO,
    "MosaicMetaDTO": mosaicMetaDTO_1.MosaicMetaDTO,
    "MosaicNamesDTO": mosaicNamesDTO_1.MosaicNamesDTO,
    "MosaicPropertyDTO": mosaicPropertyDTO_1.MosaicPropertyDTO,
    "MultisigAccountGraphInfoDTO": multisigAccountGraphInfoDTO_1.MultisigAccountGraphInfoDTO,
    "MultisigAccountInfoDTO": multisigAccountInfoDTO_1.MultisigAccountInfoDTO,
    "MultisigDTO": multisigDTO_1.MultisigDTO,
    "NamespaceDTO": namespaceDTO_1.NamespaceDTO,
    "NamespaceIds": namespaceIds_1.NamespaceIds,
    "NamespaceInfoDTO": namespaceInfoDTO_1.NamespaceInfoDTO,
    "NamespaceMetaDTO": namespaceMetaDTO_1.NamespaceMetaDTO,
    "NamespaceNameDTO": namespaceNameDTO_1.NamespaceNameDTO,
    "NetworkTypeDTO": networkTypeDTO_1.NetworkTypeDTO,
    "NodeInfoDTO": nodeInfoDTO_1.NodeInfoDTO,
    "NodeTimeDTO": nodeTimeDTO_1.NodeTimeDTO,
    "ResolutionEntryDTO": resolutionEntryDTO_1.ResolutionEntryDTO,
    "ResolutionStatementDTO": resolutionStatementDTO_1.ResolutionStatementDTO,
    "ServerDTO": serverDTO_1.ServerDTO,
    "ServerInfoDTO": serverInfoDTO_1.ServerInfoDTO,
    "SourceDTO": sourceDTO_1.SourceDTO,
    "StatementsDTO": statementsDTO_1.StatementsDTO,
    "StorageInfoDTO": storageInfoDTO_1.StorageInfoDTO,
    "TransactionHashes": transactionHashes_1.TransactionHashes,
    "TransactionIds": transactionIds_1.TransactionIds,
    "TransactionInfoDTO": transactionInfoDTO_1.TransactionInfoDTO,
    "TransactionMetaDTO": transactionMetaDTO_1.TransactionMetaDTO,
    "TransactionPayload": transactionPayload_1.TransactionPayload,
    "TransactionStatementDTO": transactionStatementDTO_1.TransactionStatementDTO,
    "TransactionStatusDTO": transactionStatusDTO_1.TransactionStatusDTO,
};
class ObjectSerializer {
    static findCorrectType(data, expectedType) {
        if (data == undefined) {
            return expectedType;
        }
        else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        }
        else if (expectedType === "Date") {
            return expectedType;
        }
        else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }
            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }
            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            }
            else {
                if (data[discriminatorProperty]) {
                    var discriminatorType = data[discriminatorProperty];
                    if (typeMap[discriminatorType]) {
                        return discriminatorType; // use the type given in the discriminator
                    }
                    else {
                        return expectedType; // discriminator did not map to a type
                    }
                }
                else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }
    static serialize(data, type) {
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) {
            let subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return data.toISOString();
        }
        else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) {
                return data;
            }
            // Get the actual type of this object
            type = this.findCorrectType(data, type);
            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }
    static deserialize(data, type) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) {
            let subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return new Date(data);
        }
        else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) {
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}
exports.ObjectSerializer = ObjectSerializer;
class HttpBasicAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    }
}
exports.HttpBasicAuth = HttpBasicAuth;
class ApiKeyAuth {
    constructor(location, paramName) {
        this.location = location;
        this.paramName = paramName;
        this.apiKey = '';
    }
    applyToRequest(requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}
exports.ApiKeyAuth = ApiKeyAuth;
class OAuth {
    constructor() {
        this.accessToken = '';
    }
    applyToRequest(requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}
exports.OAuth = OAuth;
class VoidAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(_) {
        // Do nothing
    }
}
exports.VoidAuth = VoidAuth;
//# sourceMappingURL=models.js.map