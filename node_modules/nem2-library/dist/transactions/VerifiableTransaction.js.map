{"version":3,"sources":["../../src/transactions/VerifiableTransaction.js"],"names":["KeyPair","require","VerifiableTransaction","bytes","schema","keyPair","byteBuffer","serialize","signingBytes","slice","keyPairEncoded","createKeyPairFromPrivateKeyString","privateKey","signature","Array","from","sign","Uint8Array","signedTransactionBuffer","splice","concat","publicKey","length","payload","convert","uint8ToHex","hash","createTransactionHash","parentHash","signer","_signer","hexToUint8","resultBytes","transactionPayload","sha3Hasher","func"],"mappings":";;;;;;qjBAAA;;;;;;;;;;;;;;;;AAgBA;;;;AACA;;;;;;;;AAEA,IAAMA,UAAUC,QAAQ,mBAAR,CAAhB;;AAEA;;;;;;IAKqBC,qB;AACpB;;;;;AAKA,gCAAYC,KAAZ,EAAmBC,MAAnB,EAA2B;AAAA;;AAC1B,OAAKD,KAAL,GAAaA,KAAb;AACA,OAAKC,MAAL,GAAcA,MAAd;AACA;;AAED;;;;;;;;;;AAoBA;;;;kCAIgBC,O,EAAS;AACxB,OAAMC,aAAa,KAAKC,SAAL,EAAnB;AACA,OAAMC,eAAeF,WAAWG,KAAX,CAAiB,IAAI,EAAJ,GAAS,EAA1B,CAArB;AACA,OAAMC,iBAAiBV,QAAQW,iCAAR,CAA0CN,QAAQO,UAAlD,CAAvB;AACA,OAAMC,YAAYC,MAAMC,IAAN,CAAWf,QAAQgB,IAAR,CAAaX,OAAb,EAAsB,IAAIY,UAAJ,CAAeT,YAAf,CAAtB,CAAX,CAAlB;AACA,OAAMU,0BAA0BZ,WAC9Ba,MAD8B,CACvB,CADuB,EACpB,CADoB,EAE9BC,MAF8B,CAEvBP,SAFuB,EAG9BO,MAH8B,CAGvBN,MAAMC,IAAN,CAAWL,eAAeW,SAA1B,CAHuB,EAI9BD,MAJ8B,CAIvBd,WACNa,MADM,CACC,KAAK,EADN,EACUb,WAAWgB,MADrB,CAJuB,CAAhC;AAMA,OAAMC,UAAUC,kBAAQC,UAAR,CAAmBP,uBAAnB,CAAhB;AACA,UAAO;AACNK,oBADM;AAENG,UAAMxB,sBAAsByB,qBAAtB,CAA4CJ,OAA5C;AAFA,IAAP;AAIA;;;8BAEW;AACX,UAAO,KAAKnB,MAAL,CAAYG,SAAZ,CAAsBO,MAAMC,IAAN,CAAW,KAAKZ,KAAhB,CAAtB,CAAP;AACA;;AAED;;;;;;iDAG+B;AAC9B,UAAOqB,kBAAQC,UAAR,CAAmB,KAAKlB,SAAL,EAAnB,CAAP;AACA;;AAED;;;;;;;+CAI6BF,O,EAAS;AACrC,OAAMQ,YAAYb,QAAQgB,IAAR,CAAaX,OAAb,EAAsB,IAAIY,UAAJ,CAAe,KAAKd,KAApB,CAAtB,CAAlB;AACA,UAAO;AACNyB,gBAAYJ,kBAAQC,UAAR,CAAmB,KAAKtB,KAAxB,CADN;AAENU,eAAWW,kBAAQC,UAAR,CAAmBZ,SAAnB,CAFL;AAGNgB,YAAQxB,QAAQgB;AAHV,IAAP;AAKA;;AAED;;;;;;;;yCAKuBS,O,EAAS;AAC/B,OAAMD,SAASL,kBAAQO,UAAR,CAAmBD,OAAnB,CAAf;AACA,OAAIE,cAAc,KAAK5B,MAAL,CAAYG,SAAZ,CAAsBO,MAAMC,IAAN,CAAW,KAAKZ,KAAhB,CAAtB,CAAlB;AACA6B,eAAYb,MAAZ,CAAmB,CAAnB,EAAsB,IAAI,EAAJ,GAAS,EAA/B;AACAa,iBAAclB,MAAMC,IAAN,CAAWc,MAAX,EAAmBT,MAAnB,CAA0BY,WAA1B,CAAd;AACAA,eAAYb,MAAZ,CAAmB,KAAK,CAAL,GAAS,CAA5B,EAA+B,EAA/B;AACA,UAAOL,MAAMC,IAAN,CAAY,IAAIE,UAAJ,CAAe,CAChCe,YAAYV,MAAZ,GAAqB,CAArB,GAAyB,UADO,EAEjC,CAACU,YAAYV,MAAZ,GAAqB,CAArB,GAAyB,UAA1B,KAAyC,CAFR,EAGjC,CAACU,YAAYV,MAAZ,GAAqB,CAArB,GAAyB,UAA1B,KAAyC,EAHR,EAIjC,CAACU,YAAYV,MAAZ,GAAqB,CAArB,GAAyB,UAA1B,KAAyC,EAJR,CAAf,CAAZ,EAKFF,MALE,CAKKY,WALL,CAAP;AAMA;;;wCA/E4BC,kB,EAAoB;AAChD,OAAM3B,aAAaQ,MAAMC,IAAN,CAAWS,kBAAQO,UAAR,CAAmBE,kBAAnB,CAAX,CAAnB;AACA,OAAMzB,eAAeF,WACnBG,KADmB,CACb,CADa,EACV,EADU,EAEnBW,MAFmB,CAEZd,WACNG,KADM,CACA,IAAI,EADJ,EACQ,IAAI,EAAJ,GAAS,EADjB,CAFY,EAInBW,MAJmB,CAIZd,WACNa,MADM,CACC,IAAI,EAAJ,GAAS,EADV,EACcb,WAAWgB,MADzB,CAJY,CAArB;;AAOA,OAAMI,OAAO,IAAIT,UAAJ,CAAe,EAAf,CAAb;;AAEAiB,wBAAWC,IAAX,CAAgBT,IAAhB,EAAsBlB,YAAtB,EAAoC,EAApC;;AAEA,UAAOgB,kBAAQC,UAAR,CAAmBC,IAAnB,CAAP;AACA;;;;;;kBA7BmBxB,qB","file":"VerifiableTransaction.js","sourcesContent":["/*\n * Copyright 2018 NEM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport convert from '../coders/convert';\nimport sha3Hasher from '../crypto/sha3Hasher';\n\nconst KeyPair = require('../crypto/keyPair');\n\n/**\n * VerifiableTransaction\n * @module transactions/VerifiableTransaction\n * @version 1.0.0\n */\nexport default class VerifiableTransaction {\n\t/**\n\t * @constructor\n\t * @param {Uint8Array} bytes Uint8Array after flatbuffers.build.asUint8Array()\n\t * @param {module:schema/Schema} schema Schema definition corresponding to flatbuffer Schema\n\t */\n\tconstructor(bytes, schema) {\n\t\tthis.bytes = bytes;\n\t\tthis.schema = schema;\n\t}\n\n\t/**\n\t * @param {string} transactionPayload HexString Payload\n\t * @returns {*|string} Returns Transaction Payload hash\n\t */\n\tstatic createTransactionHash(transactionPayload) {\n\t\tconst byteBuffer = Array.from(convert.hexToUint8(transactionPayload));\n\t\tconst signingBytes = byteBuffer\n\t\t\t.slice(4, 36)\n\t\t\t.concat(byteBuffer\n\t\t\t\t.slice(4 + 64, 4 + 64 + 32))\n\t\t\t.concat(byteBuffer\n\t\t\t\t.splice(4 + 64 + 32, byteBuffer.length));\n\n\t\tconst hash = new Uint8Array(32);\n\n\t\tsha3Hasher.func(hash, signingBytes, 32);\n\n\t\treturn convert.uint8ToHex(hash);\n\t}\n\n\t/**\n\t * @param {KeyPair } keyPair KeyPair instance\n\t * @returns {module:model/TransactionPayload} - Signed Transaction Payload\n\t */\n\tsignTransaction(keyPair) {\n\t\tconst byteBuffer = this.serialize();\n\t\tconst signingBytes = byteBuffer.slice(4 + 64 + 32);\n\t\tconst keyPairEncoded = KeyPair.createKeyPairFromPrivateKeyString(keyPair.privateKey);\n\t\tconst signature = Array.from(KeyPair.sign(keyPair, new Uint8Array(signingBytes)));\n\t\tconst signedTransactionBuffer = byteBuffer\n\t\t\t.splice(0, 4)\n\t\t\t.concat(signature)\n\t\t\t.concat(Array.from(keyPairEncoded.publicKey))\n\t\t\t.concat(byteBuffer\n\t\t\t\t.splice(64 + 32, byteBuffer.length));\n\t\tconst payload = convert.uint8ToHex(signedTransactionBuffer);\n\t\treturn {\n\t\t\tpayload,\n\t\t\thash: VerifiableTransaction.createTransactionHash(payload)\n\t\t};\n\t}\n\n\tserialize() {\n\t\treturn this.schema.serialize(Array.from(this.bytes));\n\t}\n\n\t/**\n\t * @returns {string} - Serialized Transaction Payload\n\t */\n\tserializeUnsignedTransaction() {\n\t\treturn convert.uint8ToHex(this.serialize());\n\t}\n\n\t/**\n\t * @param {KeyPair} keyPair KeyPair instance\n\t * @returns {module:model/TransactionPayload} Returns TransactionPayload instance\n\t */\n\tsignCosignatoriesTransaction(keyPair) {\n\t\tconst signature = KeyPair.sign(keyPair, new Uint8Array(this.bytes));\n\t\treturn {\n\t\t\tparentHash: convert.uint8ToHex(this.bytes),\n\t\t\tsignature: convert.uint8ToHex(signature),\n\t\t\tsigner: keyPair.publicKey\n\t\t};\n\t}\n\n\t/**\n\t * Converts the transaction into AggregateTransaction compatible\n\t * @param {string} [_signer] Signer public key\n\t * @returns {Array.<*>} AggregateTransaction bytes\n\t */\n\ttoAggregateTransaction(_signer) {\n\t\tconst signer = convert.hexToUint8(_signer);\n\t\tlet resultBytes = this.schema.serialize(Array.from(this.bytes));\n\t\tresultBytes.splice(0, 4 + 64 + 32);\n\t\tresultBytes = Array.from(signer).concat(resultBytes);\n\t\tresultBytes.splice(32 + 2 + 2, 16);\n\t\treturn Array.from((new Uint8Array([\n\t\t\t(resultBytes.length + 4 & 0x000000ff),\n\t\t\t(resultBytes.length + 4 & 0x0000ff00) >> 8,\n\t\t\t(resultBytes.length + 4 & 0x00ff0000) >> 16,\n\t\t\t(resultBytes.length + 4 & 0xff000000) >> 24\n\t\t]))).concat(resultBytes);\n\t}\n}\n"]}