{"version":3,"sources":["../../src/coders/address.js"],"names":["constants","sizes","ripemd160","addressDecoded","addressEncoded","key","checksum","address","stringToAddress","encoded","length","Error","base32","decode","aliasToRecipient","padded","Uint8Array","set","namespaceId","reverse","convert","hexToUint8","repeat","addressToString","decoded","uint8ToHex","encode","publicKeyToAddress","publicKey","networkIdentifier","publicKeyHash","sha3_256","arrayBuffer","ripemdHash","Ripemd160","update","Buffer","digest","decodedAddress","array","copy","hash","subarray","uint8View","isValidAddress","create","checksumBegin","deepEqual","isValidEncodedAddress","err"],"mappings":"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","file":"address.js","sourcesContent":["/*\n * Copyright 2018 NEM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { sha3_256 } from 'js-sha3';\nimport Ripemd160 from 'ripemd160';\nimport array from './array';\nimport base32 from './base32';\nimport convert from './convert';\n\nconst constants = {\n\tsizes: {\n\t\tripemd160: 20,\n\t\taddressDecoded: 25,\n\t\taddressEncoded: 40,\n\t\tkey: 32,\n\t\tchecksum: 4\n\t}\n};\n\n/** @exports coders/address */\nconst address = {\n\t/**\n\t * Converts an encoded address string to a decoded address.\n\t * @param {string} encoded The encoded address string.\n\t * @returns {Uint8Array} The decoded address corresponding to the input.\n\t */\n\tstringToAddress: encoded => {\n\t\tif (constants.sizes.addressEncoded !== encoded.length)\n\t\t\tthrow Error(`${encoded} does not represent a valid encoded address`);\n\n\t\treturn base32.decode(encoded);\n\t},\n\n\t/**\n\t * Format a namespaceId *alias* into a valid recipient field value.\n\t * @param {string} namespaceId The hexadecimal namespaceId\n\t * @returns {Uint8Array} The padded hexadecimal notation of the alias\n\t */\n\taliasToRecipient: namespaceId => {\n\t\t// 0x91 | namespaceId on 8 bytes | 16 bytes 0-pad = 25 bytes\n\t\tconst padded = new Uint8Array(1 + 8 + 16);\n\t\tpadded.set([0x91], 0);\n\t\tpadded.set(namespaceId.reverse(), 1);\n\t\tpadded.set(convert.hexToUint8('00'.repeat(16)), 9);\n\t\treturn padded;\n\t},\n\n\t/**\n\t * Converts a decoded address to an encoded address string.\n\t * @param {Uint8Array} decoded The decoded address.\n\t * @returns {string} The encoded address string corresponding to the input.\n\t */\n\taddressToString: decoded => {\n\t\tif (constants.sizes.addressDecoded !== decoded.length)\n\t\t\tthrow Error(`${convert.uint8ToHex(decoded)} does not represent a valid decoded address`);\n\n\t\treturn base32.encode(decoded);\n\t},\n\n\t/**\n\t * Converts a public key to a decoded address for a specific network.\n\t * @param {module:crypto/keyPair~PublicKey} publicKey The public key.\n\t * @param {number} networkIdentifier The network identifier.\n\t * @returns {Uint8Array} The decoded address corresponding to the inputs.\n\t */\n\tpublicKeyToAddress: (publicKey, networkIdentifier) => {\n\t\t// step 1: sha3 hash of the public key\n\t\tconst publicKeyHash = sha3_256.arrayBuffer(publicKey);\n\n\t\t// step 2: ripemd160 hash of (1)\n\t\tconst ripemdHash = new Ripemd160().update(new Buffer(publicKeyHash)).digest();\n\n\t\t// step 3: add network identifier byte in front of (2)\n\t\tconst decodedAddress = new Uint8Array(constants.sizes.addressDecoded);\n\t\tdecodedAddress[0] = networkIdentifier;\n\t\tarray.copy(decodedAddress, ripemdHash, constants.sizes.ripemd160, 1);\n\n\t\t// step 4: concatenate (3) and the checksum of (3)\n\t\tconst hash = sha3_256.arrayBuffer(decodedAddress.subarray(0, constants.sizes.ripemd160 + 1));\n\t\tarray.copy(decodedAddress, array.uint8View(hash), constants.sizes.checksum, constants.sizes.ripemd160 + 1);\n\n\t\treturn decodedAddress;\n\t},\n\n\t/**\n\t * Determines the validity of a decoded address.\n\t * @param {Uint8Array} decoded The decoded address.\n\t * @returns {boolean} true if the decoded address is valid, false otherwise.\n\t */\n\tisValidAddress: decoded => {\n\t\tconst hash = sha3_256.create();\n\t\tconst checksumBegin = constants.sizes.addressDecoded - constants.sizes.checksum;\n\t\thash.update(decoded.subarray(0, checksumBegin));\n\t\tconst checksum = new Uint8Array(constants.sizes.checksum);\n\t\tarray.copy(checksum, array.uint8View(hash.arrayBuffer()), constants.sizes.checksum);\n\t\treturn array.deepEqual(checksum, decoded.subarray(checksumBegin));\n\t},\n\n\t/**\n\t * Determines the validity of an encoded address string.\n\t * @param {string} encoded The encoded address string.\n\t * @returns {boolean} true if the encoded address string is valid, false otherwise.\n\t */\n\tisValidEncodedAddress: encoded => {\n\t\tif (constants.sizes.addressEncoded !== encoded.length)\n\t\t\treturn false;\n\n\t\ttry {\n\t\t\tconst decoded = address.stringToAddress(encoded);\n\t\t\treturn address.isValidAddress(decoded);\n\t\t} catch (err) {\n\t\t\treturn false;\n\t\t}\n\t}\n};\n\nexport default address;\n"]}