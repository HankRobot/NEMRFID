{"version":3,"sources":["../../src/coders/uint64.js"],"names":["readUint32At","bytes","i","compact","low","uint64","high","fromUint","value","number","fromBytes","uint8Array","length","Error","fromBytes32","fromHex","input","hexString","repeat","convert","hexToUint8","view","DataView","buffer","getUint32","toHex","uint32Array","Uint32Array","uint32ToUint8","reverse","uint8ToHex","isZero"],"mappings":";;;;;;AAkBA;;;;;;AAEA,IAAMA,eAAe,SAAfA,YAAe,CAACC,KAAD,EAAQC,CAAR;AAAA,QAAeD,MAAMC,CAAN,KAAYD,MAAMC,IAAI,CAAV,KAAgB,CAA5B,KAAkCD,MAAMC,IAAI,CAAV,KAAgB,EAAlD,KAAyDD,MAAMC,IAAI,CAAV,KAAgB,EAAzE,CAAD,KAAmF,CAAjG;AAAA,CAArB;;AAEA;;;;;;;AAtBA;;;;;;;;;;;;;;;;AAgBA;;kBAae;AACd;;;;;;AAMAC,UAAS,yBAAU;AAClB,MAAMC,MAAMC,OAAO,CAAP,CAAZ;AACA,MAAMC,OAAOD,OAAO,CAAP,CAAb;;AAEA;AACA,MAAI,cAAcC,IAAlB,EACC,OAAOD,MAAP;;AAED;AACA,SAAQC,OAAO,WAAR,GAAuBF,GAA9B;AACA,EAjBa;;AAmBd;;;;;AAKAG,WAAU,0BAAU;AACnB,MAAMC,QAAQ,CAAC,CAACC,SAAS,UAAV,MAA0B,CAA3B,EAA+BA,SAAS,WAAV,KAA2B,CAAzD,CAAd;AACA;AACA;;AAEA,SAAOD,KAAP;AACA,EA9Ba;;AAgCd;;;;;AAKAE,YAAW,+BAAc;AACxB,MAAI,MAAMC,WAAWC,MAArB,EACC,MAAMC,4CAAyCF,WAAWC,MAApD,QAAN;;AAED,SAAO,CAACZ,aAAaW,UAAb,EAAyB,CAAzB,CAAD,EAA8BX,aAAaW,UAAb,EAAyB,CAAzB,CAA9B,CAAP;AACA,EA1Ca;;AA4Cd;;;;;AAKAG,cAAa,iCAAc;AAC1B,MAAI,MAAMH,WAAWC,MAArB,EACC,MAAMC,4CAAyCF,WAAWC,MAApD,QAAN;;AAED,SAAO,CAACZ,aAAaW,UAAb,EAAyB,CAAzB,CAAD,EAA8B,CAA9B,CAAP;AACA,EAtDa;;AAwDd;;;;;AAKAI,UAAS,wBAAS;AACjB,MAAI,OAAOC,MAAMJ,MAAjB,EACC,MAAMC,4CAAyCG,MAAMJ,MAA/C,QAAN;;AAED,MAAIK,YAAYD,KAAhB;AACA,MAAI,KAAKC,UAAUL,MAAnB,EACCK,YAAY,IAAIC,MAAJ,CAAW,KAAKD,UAAUL,MAA1B,IAAoCK,SAAhD;;AAED,MAAMN,aAAaQ,kBAAQC,UAAR,CAAmBH,SAAnB,CAAnB;AACA,MAAMI,OAAO,IAAIC,QAAJ,CAAaX,WAAWY,MAAxB,CAAb;AACA,SAAO,CAACF,KAAKG,SAAL,CAAe,CAAf,CAAD,EAAoBH,KAAKG,SAAL,CAAe,CAAf,CAApB,CAAP;AACA,EAxEa;;AA0Ed;;;;;AAKAC,QAAO,uBAAU;AAChB,MAAMC,cAAc,IAAIC,WAAJ,CAAgBtB,MAAhB,CAApB;AACA,MAAMM,aAAaQ,kBAAQS,aAAR,CAAsBF,WAAtB,EAAmCG,OAAnC,EAAnB;AACA,SAAOV,kBAAQW,UAAR,CAAmBnB,UAAnB,CAAP;AACA,EAnFa;;AAqFd;;;;;AAKAoB,SAAQ;AAAA,SAAU,MAAM1B,OAAO,CAAP,CAAN,IAAmB,MAAMA,OAAO,CAAP,CAAnC;AAAA;AA1FM,C","file":"uint64.js","sourcesContent":["/*\n * Copyright 2018 NEM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @module coders/uint64 */\n\nimport convert from './convert';\n\nconst readUint32At = (bytes, i) => (bytes[i] + (bytes[i + 1] << 8) + (bytes[i + 2] << 16) + (bytes[i + 3] << 24)) >>> 0;\n\n/**\n * An exact uint64 representation composed of two 32bit values.\n * @typedef {Array} uint64\n * @property {number} 0 The low 32bit value.\n * @property {number} 1 The high 32bit value.\n */\n\nexport default {\n\t/**\n\t * Tries to compact a uint64 into a simple numeric.\n\t * @param {module:coders/uint64~uint64} uint64 A uint64 value.\n\t * @returns {number|module:coders/uint64~uint64}\n\t * A numeric if the uint64 is no greater than Number.MAX_SAFE_INTEGER or the original uint64 value otherwise.\n\t */\n\tcompact: uint64 => {\n\t\tconst low = uint64[0];\n\t\tconst high = uint64[1];\n\n\t\t// don't compact if the value is >= 2^53\n\t\tif (0x00200000 <= high)\n\t\t\treturn uint64;\n\n\t\t// multiply because javascript bit operations operate on 32bit values\n\t\treturn (high * 0x100000000) + low;\n\t},\n\n\t/**\n\t * Converts a numeric unsigned integer into a uint64.\n\t * @param {number} number The unsigned integer.\n\t * @returns {module:coders/uint64~uint64} The uint64 representation of the input.\n\t */\n\tfromUint: number => {\n\t\tconst value = [(number & 0xFFFFFFFF) >>> 0, (number / 0x100000000) >>> 0];\n\t\t//if (0x00200000 <= value[1] || 0 > number || 0 !== (number % 1))\n\t\t//\tthrow Error(`number cannot be converted to uint '${number}'`);\n\n\t\treturn value;\n\t},\n\n\t/**\n\t * Converts a (64bit) uint8 array into a uint64.\n\t * @param {Uint8Array} uint8Array A uint8 array.\n\t * @returns {module:coders/uint64~uint64} The uint64 representation of the input.\n\t */\n\tfromBytes: uint8Array => {\n\t\tif (8 !== uint8Array.length)\n\t\t\tthrow Error(`byte array has unexpected size '${uint8Array.length}'`);\n\n\t\treturn [readUint32At(uint8Array, 0), readUint32At(uint8Array, 4)];\n\t},\n\n\t/**\n\t * Converts a (32bit) uint8 array into a uint64.\n\t * @param {Uint8Array} uint8Array A uint8 array.\n\t * @returns {module:coders/uint64~uint64} The uint64 representation of the input.\n\t */\n\tfromBytes32: uint8Array => {\n\t\tif (4 !== uint8Array.length)\n\t\t\tthrow Error(`byte array has unexpected size '${uint8Array.length}'`);\n\n\t\treturn [readUint32At(uint8Array, 0), 0];\n\t},\n\n\t/**\n\t * Parses a hex string into a uint64.\n\t * @param {string} input A hex encoded string.\n\t * @returns {module:coders/uint64~uint64} The uint64 representation of the input.\n\t */\n\tfromHex: input => {\n\t\tif (16 !== input.length)\n\t\t\tthrow Error(`hex string has unexpected size '${input.length}'`);\n\n\t\tlet hexString = input;\n\t\tif (16 > hexString.length)\n\t\t\thexString = '0'.repeat(16 - hexString.length) + hexString;\n\n\t\tconst uint8Array = convert.hexToUint8(hexString);\n\t\tconst view = new DataView(uint8Array.buffer);\n\t\treturn [view.getUint32(4), view.getUint32(0)];\n\t},\n\n\t/**\n\t * Converts a uint64 into a hex string.\n\t * @param {module:coders/uint64~uint64} uint64 A uint64 value.\n\t * @returns {string} A hex encoded string representing the uint64.\n\t */\n\ttoHex: uint64 => {\n\t\tconst uint32Array = new Uint32Array(uint64);\n\t\tconst uint8Array = convert.uint32ToUint8(uint32Array).reverse();\n\t\treturn convert.uint8ToHex(uint8Array);\n\t},\n\n\t/**\n\t * Returns true if a uint64 is zero.\n\t * @param {module:coders/uint64~uint64} uint64 A uint64 value.\n\t * @returns {boolean} true if the value is zero.\n\t */\n\tisZero: uint64 => 0 === uint64[0] && 0 === uint64[1]\n};\n"]}