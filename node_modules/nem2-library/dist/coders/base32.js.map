{"version":3,"sources":["../../src/coders/base32.js"],"names":["Alphabet","Decoded_Block_Size","Encoded_Block_Size","encodeBlock","input","inputOffset","output","outputOffset","Char_To_Decoded_Char_Map","builder","charMapping","createBuilder","addRange","map","decodeChar","c","decodedChar","undefined","Error","decodeBlock","bytes","Uint8Array","i","encode","data","length","Array","join","decode","encoded"],"mappings":";;;;;;AAiBA;;;;;;AAEA,IAAMA,WAAW,kCAAjB,C,CAnBA;;;;;;;;;;;;;;;;AAgBA;;AAIA,IAAMC,qBAAqB,CAA3B;AACA,IAAMC,qBAAqB,CAA3B;;AAEA;;AAEA,SAASC,WAAT,CAAqBC,KAArB,EAA4BC,WAA5B,EAAyCC,MAAzC,EAAiDC,YAAjD,EAA+D;AAC9DD,QAAOC,eAAe,CAAtB,IAA2BP,SAASI,MAAMC,cAAc,CAApB,KAA0B,CAAnC,CAA3B;AACAC,QAAOC,eAAe,CAAtB,IAA2BP,SAAU,CAACI,MAAMC,cAAc,CAApB,IAAyB,IAA1B,KAAmC,CAApC,GAA0CD,MAAMC,cAAc,CAApB,KAA0B,CAA7E,CAA3B;AACAC,QAAOC,eAAe,CAAtB,IAA2BP,SAAS,CAACI,MAAMC,cAAc,CAApB,IAAyB,IAA1B,KAAmC,CAA5C,CAA3B;AACAC,QAAOC,eAAe,CAAtB,IAA2BP,SAAU,CAACI,MAAMC,cAAc,CAApB,IAAyB,IAA1B,KAAmC,CAApC,GAA0CD,MAAMC,cAAc,CAApB,KAA0B,CAA7E,CAA3B;AACAC,QAAOC,eAAe,CAAtB,IAA2BP,SAAU,CAACI,MAAMC,cAAc,CAApB,IAAyB,IAA1B,KAAmC,CAApC,GAA0CD,MAAMC,cAAc,CAApB,KAA0B,CAA7E,CAA3B;AACAC,QAAOC,eAAe,CAAtB,IAA2BP,SAAS,CAACI,MAAMC,cAAc,CAApB,IAAyB,IAA1B,KAAmC,CAA5C,CAA3B;AACAC,QAAOC,eAAe,CAAtB,IAA2BP,SAAU,CAACI,MAAMC,cAAc,CAApB,IAAyB,IAA1B,KAAmC,CAApC,GAA0CD,MAAMC,cAAc,CAApB,KAA0B,CAA7E,CAA3B;AACAC,QAAOC,eAAe,CAAtB,IAA2BP,SAASI,MAAMC,cAAc,CAApB,IAAyB,IAAlC,CAA3B;AACA;;AAED;;AAEA;;AAEA,IAAMG,2BAA4B,YAAY;AAC7C,KAAMC,UAAUC,sBAAYC,aAAZ,EAAhB;AACAF,SAAQG,QAAR,CAAiB,GAAjB,EAAsB,GAAtB,EAA2B,CAA3B;AACAH,SAAQG,QAAR,CAAiB,GAAjB,EAAsB,GAAtB,EAA2B,EAA3B;AACA,QAAOH,QAAQI,GAAf;AACA,CALgC,EAAjC;;AAOA,SAASC,UAAT,CAAoBC,CAApB,EAAuB;AACtB,KAAMC,cAAcR,yBAAyBO,CAAzB,CAApB;AACA,KAAIE,cAAcD,WAAlB,EACC,OAAOA,WAAP;;AAED,OAAME,oCAAkCH,CAAlC,CAAN;AACA;;AAED,SAASI,WAAT,CAAqBf,KAArB,EAA4BC,WAA5B,EAAyCC,MAAzC,EAAiDC,YAAjD,EAA+D;AAC9D,KAAMa,QAAQ,IAAIC,UAAJ,CAAenB,kBAAf,CAAd;AACA,MAAK,IAAIoB,IAAI,CAAb,EAAgBA,IAAIpB,kBAApB,EAAwC,EAAEoB,CAA1C;AACCF,QAAME,CAAN,IAAWR,WAAWV,MAAMC,cAAciB,CAApB,CAAX,CAAX;AADD,EAGAhB,OAAOC,eAAe,CAAtB,IAA4Ba,MAAM,CAAN,KAAY,CAAb,GAAmBA,MAAM,CAAN,KAAY,CAA1D;AACAd,QAAOC,eAAe,CAAtB,IAA4B,CAACa,MAAM,CAAN,IAAW,IAAZ,KAAqB,CAAtB,GAA4BA,MAAM,CAAN,KAAY,CAAxC,GAA8CA,MAAM,CAAN,KAAY,CAArF;AACAd,QAAOC,eAAe,CAAtB,IAA4B,CAACa,MAAM,CAAN,IAAW,IAAZ,KAAqB,CAAtB,GAA4BA,MAAM,CAAN,KAAY,CAAnE;AACAd,QAAOC,eAAe,CAAtB,IAA4B,CAACa,MAAM,CAAN,IAAW,IAAZ,KAAqB,CAAtB,GAA4BA,MAAM,CAAN,KAAY,CAAxC,GAA8CA,MAAM,CAAN,KAAY,CAArF;AACAd,QAAOC,eAAe,CAAtB,IAA4B,CAACa,MAAM,CAAN,IAAW,IAAZ,KAAqB,CAAtB,GAA2BA,MAAM,CAAN,CAAtD;AACA;;AAED;;kBAEe;AACd;;;;;AAKAG,SAAQ,sBAAQ;AACf,MAAI,MAAMC,KAAKC,MAAL,GAAcxB,kBAAxB,EACC,MAAMiB,4CAA0CjB,kBAA1C,CAAN;;AAED,MAAMK,SAAS,IAAIoB,KAAJ,CAAUF,KAAKC,MAAL,GAAcxB,kBAAd,GAAmCC,kBAA7C,CAAf;AACA,OAAK,IAAIoB,IAAI,CAAb,EAAgBA,IAAIE,KAAKC,MAAL,GAAcxB,kBAAlC,EAAsD,EAAEqB,CAAxD;AACCnB,eAAYqB,IAAZ,EAAkBF,IAAIrB,kBAAtB,EAA0CK,MAA1C,EAAkDgB,IAAIpB,kBAAtD;AADD,GAGA,OAAOI,OAAOqB,IAAP,CAAY,EAAZ,CAAP;AACA,EAfa;;AAiBd;;;;;AAKAC,SAAQ,yBAAW;AAClB,MAAI,MAAMC,QAAQJ,MAAR,GAAiBvB,kBAA3B,EACC,MAAMgB,4CAA0ChB,kBAA1C,CAAN;;AAED,MAAMI,SAAS,IAAIe,UAAJ,CAAeQ,QAAQJ,MAAR,GAAiBvB,kBAAjB,GAAsCD,kBAArD,CAAf;AACA,OAAK,IAAIqB,IAAI,CAAb,EAAgBA,IAAIO,QAAQJ,MAAR,GAAiBvB,kBAArC,EAAyD,EAAEoB,CAA3D;AACCH,eAAYU,OAAZ,EAAqBP,IAAIpB,kBAAzB,EAA6CI,MAA7C,EAAqDgB,IAAIrB,kBAAzD;AADD,GAGA,OAAOK,MAAP;AACA;AA/Ba,C","file":"base32.js","sourcesContent":["/*\n * Copyright 2018 NEM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @module coders/base32 */\nimport charMapping from './charMapping';\n\nconst Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\nconst Decoded_Block_Size = 5;\nconst Encoded_Block_Size = 8;\n\n// region encode\n\nfunction encodeBlock(input, inputOffset, output, outputOffset) {\n\toutput[outputOffset + 0] = Alphabet[input[inputOffset + 0] >> 3];\n\toutput[outputOffset + 1] = Alphabet[((input[inputOffset + 0] & 0x07) << 2) | (input[inputOffset + 1] >> 6)];\n\toutput[outputOffset + 2] = Alphabet[(input[inputOffset + 1] & 0x3E) >> 1];\n\toutput[outputOffset + 3] = Alphabet[((input[inputOffset + 1] & 0x01) << 4) | (input[inputOffset + 2] >> 4)];\n\toutput[outputOffset + 4] = Alphabet[((input[inputOffset + 2] & 0x0F) << 1) | (input[inputOffset + 3] >> 7)];\n\toutput[outputOffset + 5] = Alphabet[(input[inputOffset + 3] & 0x7F) >> 2];\n\toutput[outputOffset + 6] = Alphabet[((input[inputOffset + 3] & 0x03) << 3) | (input[inputOffset + 4] >> 5)];\n\toutput[outputOffset + 7] = Alphabet[input[inputOffset + 4] & 0x1F];\n}\n\n// endregion\n\n// region decode\n\nconst Char_To_Decoded_Char_Map = (function () {\n\tconst builder = charMapping.createBuilder();\n\tbuilder.addRange('A', 'Z', 0);\n\tbuilder.addRange('2', '7', 26);\n\treturn builder.map;\n})();\n\nfunction decodeChar(c) {\n\tconst decodedChar = Char_To_Decoded_Char_Map[c];\n\tif (undefined !== decodedChar)\n\t\treturn decodedChar;\n\n\tthrow Error(`illegal base32 character ${c}`);\n}\n\nfunction decodeBlock(input, inputOffset, output, outputOffset) {\n\tconst bytes = new Uint8Array(Encoded_Block_Size);\n\tfor (let i = 0; i < Encoded_Block_Size; ++i)\n\t\tbytes[i] = decodeChar(input[inputOffset + i]);\n\n\toutput[outputOffset + 0] = (bytes[0] << 3) | (bytes[1] >> 2);\n\toutput[outputOffset + 1] = ((bytes[1] & 0x03) << 6) | (bytes[2] << 1) | (bytes[3] >> 4);\n\toutput[outputOffset + 2] = ((bytes[3] & 0x0F) << 4) | (bytes[4] >> 1);\n\toutput[outputOffset + 3] = ((bytes[4] & 0x01) << 7) | (bytes[5] << 2) | (bytes[6] >> 3);\n\toutput[outputOffset + 4] = ((bytes[6] & 0x07) << 5) | bytes[7];\n}\n\n// endregion\n\nexport default {\n\t/**\n\t * Base32 encodes a binary buffer.\n\t * @param {Uint8Array} data The binary data to encode.\n\t * @returns {string} The base32 encoded string corresponding to the input data.\n\t */\n\tencode: data => {\n\t\tif (0 !== data.length % Decoded_Block_Size)\n\t\t\tthrow Error(`decoded size must be multiple of ${Decoded_Block_Size}`);\n\n\t\tconst output = new Array(data.length / Decoded_Block_Size * Encoded_Block_Size);\n\t\tfor (let i = 0; i < data.length / Decoded_Block_Size; ++i)\n\t\t\tencodeBlock(data, i * Decoded_Block_Size, output, i * Encoded_Block_Size);\n\n\t\treturn output.join('');\n\t},\n\n\t/**\n\t * Base32 decodes a base32 encoded string.\n\t * @param {string} encoded The base32 encoded string to decode.\n\t * @returns {Uint8Array} The binary data corresponding to the input string.\n\t */\n\tdecode: encoded => {\n\t\tif (0 !== encoded.length % Encoded_Block_Size)\n\t\t\tthrow Error(`encoded size must be multiple of ${Encoded_Block_Size}`);\n\n\t\tconst output = new Uint8Array(encoded.length / Encoded_Block_Size * Decoded_Block_Size);\n\t\tfor (let i = 0; i < encoded.length / Encoded_Block_Size; ++i)\n\t\t\tdecodeBlock(encoded, i * Encoded_Block_Size, output, i * Decoded_Block_Size);\n\n\t\treturn output;\n\t}\n};\n"]}