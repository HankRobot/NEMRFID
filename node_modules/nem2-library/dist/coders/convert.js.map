{"version":3,"sources":["../../src/coders/convert.js"],"names":["Char_To_Nibble_Map","builder","charMapping","createBuilder","addRange","map","Char_To_Digit_Map","Nibble_To_Char_Map","tryParseByte","char1","char2","nibble1","nibble2","undefined","convert","toByte","byte","Error","isHexString","input","length","i","hexToUint8","output","Uint8Array","hexToUint8Reverse","uint8ToHex","s","tryParseUint","str","value","char","digit","Number","MAX_SAFE_INTEGER","uint8ToUint32","Uint32Array","buffer","uint32ToUint8","uint8ToInt8","int8ToUint8","utf8ToHex","rawString","rstr2utf8","result","charCodeAt","toString","n","c","String","fromCharCode"],"mappings":"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","file":"convert.js","sourcesContent":["/*\n * Copyright 2018 NEM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport charMapping from './charMapping';\n\nconst Char_To_Nibble_Map = (function () {\n\tconst builder = charMapping.createBuilder();\n\tbuilder.addRange('0', '9', 0);\n\tbuilder.addRange('a', 'f', 10);\n\tbuilder.addRange('A', 'F', 10);\n\treturn builder.map;\n})();\n\nconst Char_To_Digit_Map = (function () {\n\tconst builder = charMapping.createBuilder();\n\tbuilder.addRange('0', '9', 0);\n\treturn builder.map;\n})();\n\nconst Nibble_To_Char_Map = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n\nfunction tryParseByte(char1, char2) {\n\tconst nibble1 = Char_To_Nibble_Map[char1];\n\tconst nibble2 = Char_To_Nibble_Map[char2];\n\treturn undefined === nibble1 || undefined === nibble2\n\t\t? undefined\n\t\t: (nibble1 << 4) | nibble2;\n}\n\n/** @exports coders/convert */\nconst convert = {\n\t/**\n\t * Decodes two hex characters into a byte.\n\t * @param {string} char1 The first hex digit.\n\t * @param {string} char2 The second hex digit.\n\t * @returns {number} The decoded byte.\n\t */\n\ttoByte: (char1, char2) => {\n\t\tconst byte = tryParseByte(char1, char2);\n\t\tif (undefined === byte)\n\t\t\tthrow Error(`unrecognized hex char '${char1}${char2}'`);\n\n\t\treturn byte;\n\t},\n\n\t/**\n\t * Determines whether or not a string is a hex string.\n\t * @param {string} input The string to test.\n\t * @returns {boolean} true if the input is a hex string, false otherwise.\n\t */\n\tisHexString: input => {\n\t\tif (0 !== input.length % 2)\n\t\t\treturn false;\n\n\t\tfor (let i = 0; i < input.length; i += 2) {\n\t\t\tif (undefined === tryParseByte(input[i], input[i + 1]))\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Converts a hex string to a uint8 array.\n\t * @param {string} input A hex encoded string.\n\t * @returns {Uint8Array} A uint8 array corresponding to the input.\n\t */\n\thexToUint8: input => {\n\t\tif (0 !== input.length % 2)\n\t\t\tthrow Error(`hex string has unexpected size '${input.length}'`);\n\n\t\tconst output = new Uint8Array(input.length / 2);\n\t\tfor (let i = 0; i < input.length; i += 2)\n\t\t\toutput[i / 2] = convert.toByte(input[i], input[i + 1]);\n\n\t\treturn output;\n\t},\n\n\t/**\n\t * Reversed convertion hex string to a uint8 array.\n\t * @param {string} input A hex encoded string.\n\t * @returns {Uint8Array} A uint8 array corresponding to the input.\n\t */\n\thexToUint8Reverse: input => {\n\t\tif (0 !== input.length % 2)\n\t\t\tthrow Error(`hex string has unexpected size '${input.length}'`);\n\n\t\tconst output = new Uint8Array(input.length / 2);\n\t\tfor (let i = 0; i < input.length; i += 2)\n\t\t\toutput[output.length - 1 - (i / 2)] = convert.toByte(input[i], input[i + 1]);\n\n\t\treturn output;\n\t},\n\n\t/**\n\t * Converts a uint8 array to a hex string.\n\t * @param {Uint8Array} input A uint8 array.\n\t * @returns {string} A hex encoded string corresponding to the input.\n\t */\n\tuint8ToHex: input => {\n\t\tlet s = '';\n\t\tfor (const byte of input) {\n\t\t\ts += Nibble_To_Char_Map[byte >> 4];\n\t\t\ts += Nibble_To_Char_Map[byte & 0x0F];\n\t\t}\n\n\t\treturn s;\n\t},\n\n\t/**\n\t * Tries to parse a string representing an unsigned integer.\n\t * @param {string} str The string to parse.\n\t * @returns {number} The number represented by the input or undefined.\n\t */\n\ttryParseUint: str => {\n\t\tif ('0' === str)\n\t\t\treturn 0;\n\n\t\tlet value = 0;\n\t\tfor (const char of str) {\n\t\t\tconst digit = Char_To_Digit_Map[char];\n\t\t\tif (undefined === digit || (0 === value && 0 === digit))\n\t\t\t\treturn undefined;\n\n\t\t\tvalue *= 10;\n\t\t\tvalue += digit;\n\n\t\t\tif (value > Number.MAX_SAFE_INTEGER)\n\t\t\t\treturn undefined;\n\t\t}\n\n\t\treturn value;\n\t},\n\n\t/**\n\t * Converts a uint8 array to a uint32 array.\n\t * @param {Uint8Array} input A uint8 array.\n\t * @returns {Uint32Array} A uint32 array created from the input.\n\t */\n\tuint8ToUint32: input => new Uint32Array(input.buffer),\n\n\t/**\n\t * Converts a uint32 array to a uint8 array.\n\t * @param {Uint32Array} input A uint32 array.\n\t * @returns {Uint8Array} A uint8 array created from the input.\n\t */\n\tuint32ToUint8: input => new Uint8Array(input.buffer),\n\n\t/** Converts an unsigned byte to a signed byte with the same binary representation.\n\t * @param {number} input An unsigned byte.\n\t * @returns {number} A signed byte with the same binary representation as the input.\n\t * */\n\tuint8ToInt8: input => {\n\t\tif (0xFF < input)\n\t\t\tthrow Error(`input '${input}' is out of range`);\n\n\t\treturn input << 24 >> 24;\n\t},\n\n\t/** Converts a signed byte to an unsigned byte with the same binary representation.\n\t * @param {number} input A signed byte.\n\t * @returns {number} An unsigned byte with the same binary representation as the input.\n\t * */\n\tint8ToUint8: input => {\n\t\tif (127 < input || -128 > input)\n\t\t\tthrow Error(`input '${input}' is out of range`);\n\n\t\treturn input & 0xFF;\n\t},\n\n\t/**\n\t * Convert UTF-8 to hex\n\t * @param {string} str - An UTF-8 string\n\t * @return {string}\n\t */\n\tutf8ToHex: str => {\n\t\tconst rawString = convert.rstr2utf8(str);\n\t\tlet result = '';\n\t\tfor (let i = 0; i < rawString.length; i++)\n\t\t\tresult += rawString.charCodeAt(i).toString(16);\n\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Converts a raw javascript string into a string of single byte characters using utf8 encoding.\n\t * This makes it easier to perform other encoding operations on the string.\n\t *\n\t * @param {string} input - A raw string\n\t *\n\t * @return {string} - UTF-8 string\n\t */\n\trstr2utf8: input => {\n\t\tlet output = '';\n\n\t\tfor (let n = 0; n < input.length; n++) {\n\t\t\tconst c = input.charCodeAt(n);\n\n\t\t\tif (128 > c) {\n\t\t\t\toutput += String.fromCharCode(c);\n\t\t\t} else if ((127 < c) && (2048 > c)) {\n\t\t\t\toutput += String.fromCharCode((c >> 6) | 192);\n\t\t\t\toutput += String.fromCharCode((c & 63) | 128);\n\t\t\t} else {\n\t\t\t\toutput += String.fromCharCode((c >> 12) | 224);\n\t\t\t\toutput += String.fromCharCode(((c >> 6) & 63) | 128);\n\t\t\t\toutput += String.fromCharCode((c & 63) | 128);\n\t\t\t}\n\t\t}\n\n\t\treturn output;\n\t}\n};\n\nexport default convert;\n"]}