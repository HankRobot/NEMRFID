{"version":3,"sources":["../../src/crypto/sha3Hasher.js"],"names":["getHasher","length","sha3_256","sha3_512","func","dest","data","hasher","hash","arrayBuffer","array","copy","uint8View","createHasher","reset","create","update","Uint8Array","convert","hexToUint8","Error","finalize","result"],"mappings":";;;;;;AAiBA;;AACA;;;;AACA;;;;;;AAEA,SAASA,SAAT,GAAgC;AAAA,KAAbC,MAAa,uEAAJ,EAAI;;AAC/B,QAAO,EAAE,IAAIC,eAAN,EAAgB,IAAIC,eAApB,GAA+BF,MAA/B,CAAP;AACA,C,CAvBD;;;;;;;;;;;;;;;;AAgBA;kBASe;AACd;;;;;;AAMAG,OAAM,cAACC,IAAD,EAAOC,IAAP,EAAaL,MAAb,EAAwB;AAC7B,MAAMM,SAASP,UAAUC,MAAV,CAAf;AACA,MAAMO,OAAOD,OAAOE,WAAP,CAAmBH,IAAnB,CAAb;AACAI,kBAAMC,IAAN,CAAWN,IAAX,EAAiBK,gBAAME,SAAN,CAAgBJ,IAAhB,CAAjB;AACA,EAXa;;AAad;;;;;AAKAK,eAAc,8BAAU;AACvB,MAAIL,aAAJ;AACA,SAAO;AACNM,UAAO,iBAAM;AACZN,WAAOR,UAAUC,MAAV,EAAkBc,MAAlB,EAAP;AACA,IAHK;AAINC,WAAQ,sBAAQ;AACf,QAAIV,gBAAgBW,UAApB,EACCT,KAAKQ,MAAL,CAAYV,IAAZ,EADD,KAEK,IAAI,aAAa,OAAOA,IAAxB,EACJE,KAAKQ,MAAL,CAAYE,kBAAQC,UAAR,CAAmBb,IAAnB,CAAZ,EADI,KAGJ,MAAMc,MAAM,uBAAN,CAAN;AACD,IAXK;AAYNC,aAAU,0BAAU;AACnBX,oBAAMC,IAAN,CAAWW,MAAX,EAAmBZ,gBAAME,SAAN,CAAgBJ,KAAKC,WAAL,EAAhB,CAAnB;AACA;AAdK,GAAP;AAgBA;AApCa,C","file":"sha3Hasher.js","sourcesContent":["/*\n * Copyright 2018 NEM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @module crypto/sha3Hasher */\nimport { sha3_256, sha3_512 } from 'js-sha3';\nimport array from '../coders/array';\nimport convert from '../coders/convert';\n\nfunction getHasher(length = 64) {\n\treturn { 32: sha3_256, 64: sha3_512 }[length];\n}\n\nexport default {\n\t/**\n\t * Calculates the hash of data.\n\t * @param {Uint8Array} dest The computed hash destination.\n\t * @param {Uint8Array} data The data to hash.\n\t * @param {numeric} length The hash length in bytes.\n\t */\n\tfunc: (dest, data, length) => {\n\t\tconst hasher = getHasher(length);\n\t\tconst hash = hasher.arrayBuffer(data);\n\t\tarray.copy(dest, array.uint8View(hash));\n\t},\n\n\t/**\n\t * Creates a hasher object.\n\t * @param {numeric} length The hash length in bytes.\n\t * @returns {object} The hasher.\n\t */\n\tcreateHasher: length => {\n\t\tlet hash;\n\t\treturn {\n\t\t\treset: () => {\n\t\t\t\thash = getHasher(length).create();\n\t\t\t},\n\t\t\tupdate: data => {\n\t\t\t\tif (data instanceof Uint8Array)\n\t\t\t\t\thash.update(data);\n\t\t\t\telse if ('string' === typeof data)\n\t\t\t\t\thash.update(convert.hexToUint8(data));\n\t\t\t\telse\n\t\t\t\t\tthrow Error('unsupported data type');\n\t\t\t},\n\t\t\tfinalize: result => {\n\t\t\t\tarray.copy(result, array.uint8View(hash.arrayBuffer()));\n\t\t\t}\n\t\t};\n\t}\n};\n"]}