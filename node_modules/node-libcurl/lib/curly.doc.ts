export { CurlyResult } from './curly'
import { CurlyResult } from './curly'
import { CurlOptionValueType } from './generated/CurlOption'

/**
 * Call this
 *
 * @public
 */
export declare interface CurlyFunction {
  /**
   * Async wrapper around the Curl class
   * It's also possible to request using a specific http verb
   *  directly by using `curly.<http-verb>(url)`
   *
   * @beta
   */
  (url: string, options?: CurlOptionValueType): Promise<CurlyResult>

  /**
   * @returns
   *
   * Returns a new instance of curly with the configured default options.
   * See {@link (curly) | curly}.
   */
  create(): CurlyFunction

  acl(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  bind(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  checkout(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  connect(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  copy(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  get(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  head(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  delete(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  link(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  lock(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  'm-search'(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  merge(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  mkactivity(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  mkcalendar(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  mkcol(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  move(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  notify(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  options(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  patch(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  post(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  propfind(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  proppatch(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  purge(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  put(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  rebind(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  report(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  search(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  source(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  subscribe(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  trace(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  unbind(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  unlink(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  unlock(url: string, options: CurlOptionValueType): Promise<CurlyResult>
  unsubscribe(url: string, options: CurlOptionValueType): Promise<CurlyResult>
}

/**
 * Async/await wrapper around {@link (Curl:class)} class.
 * Async/await wrapper around {@link (Curl:Class)} class.
 * Async/await wrapper around {@link (Curl:CLASS)} class.
 * Async/await wrapper around {@link (Curl:namespace)} class.
 * Async/await wrapper around {@link (Curl:interface)} class.
 * Async/await wrapper around {@link (Curl:function)} class.
 *
 * @returns
 * Returns a promise that resolves to {@link CurlyResult}
 *
 * @beta
 */
export declare function curly(
  url: string,
  options: CurlOptionValueType,
): Promise<CurlyResult>
